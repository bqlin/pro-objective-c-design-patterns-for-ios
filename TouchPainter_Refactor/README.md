# Objectiv-C编程之道 iOS设计模式解析

## 对象创建

### 原型

原型模式：使用原型实例指定创建对象的种类，并通过复制这个原型创建新的对象。

关键词：复制

体现：

遵守 `Mark` 协议的类都实现了 `NSCopying` 协议，以确保实例对象是可复制的。

### 工厂方法

工厂方法模式：定义创建对象的接口，让子类决定实例化哪一个类。工厂方法使得一个类的实例化延迟到其子类。

关键词：定义接口、创建子类

体现：

`CanvasView` 类的生成延迟到子类实现。

### 抽象工厂

抽象工厂：提供一个建立一系列相关或相互依赖对象的接口，而无需指定他们具体的类。

关键词：一系列子类对象接口

体现：

`Foundation` 中的类簇（Class Cluster，如 `NSNumber` 的实现），基于抽象工厂模式，将若干相关的私有具体工厂子类集合到一个公有的抽象超类之下。

### 生成器

生成器模式：将一个复杂对象的构建与它的表现分离，使得相同的构建过程可以创建不同的表现。

关键词：分布创建对象、最后一步返回对象产品

体现：

使用 `CharacterBuilder` 子类 `StandardCharacterBuilder` 链式分布构建 `Character` 对象。

### 单例

单例模式：保证一个类仅有一个实例，并提供一个访问它的全局访问点。

关键词：一个类仅有一个实例

## 接口适配

### 适配器

适配器模式：将一个类的接口转换成客户希望的另一个接口。适配器模式使得原本有与接口不兼容而不能一起工作。

关键词：接口兼容

体现：

委托模式属于对象适配器。

### 桥接

桥接模式：将抽象部分与它的实现部分分离，使它们都可以独立地变化。

关键词：抽象与实现分离、独立变化

A、B作为抽象类，用于定义基础的属性与方法接口，A 引用 B（B 作为 A 的属性，A → B），两者只有这种桥接关系。A 及 A 的子类操作 B 的抽象接口。B 的抽象接口的实现由 B 的子类完成，可按照不同的业务封装不同的子类，但接口还是 B 的抽象接口。A 当然也可以根据业务实现其不同的子类，但对 B 及其子类对象的操作，仅限于 B 定义的抽象接口。

### 外观

外观模式：为系统中的一组接口提供一个统一的接口。外观定义一个高层接口，让子系统更易于使用。

关键词：封装一组操作

为多个类/模块的多步操作定义个高层接口，一个接口完成一连串复杂的工作。

## 对象去耦

### 中介者

中介者模式：使用一个对象来封装一系列对象的交互方式。中介者使各对象不需要显式地相互引用，从而可以独立地改变它们之间的交互。

关键词：通过在对象中封装，解除相互引用。

中介者模式以中介者内部的复杂性代替交互的复杂性。因为中介者封装与合并了 colleague 的各种协作逻辑，自身可能变得比它们任何一个都复杂，这会让中介者本省成为无所不知的庞然大物，并且难以维护。

对于处理分散于不同对象的行为并且对象相互依存的情况，中介者非常有用，但也避免让中介者变得庞大难以维护。

### 观察者

观察者模式 = 发布-订阅模式

观察者模式：定义对象间的一种一对多的依赖关系，当一个关系对象的状态发生变化时，所有依赖于它的对象都得到通知并被自动更新。

关键词：改变即接到通知以自动更新

在 TouchPainter 中的体现：

CanvasViewController 接收并处理触摸事件，并更新器 Scribble 模型。CanvasViewController 监听/观察 Scribble 模型的变更，并在其 KVO 响应中，更新 CanvasView。

## 抽象集合

### 组合

组合模式：将对象组合成__树形结构__以表示“部分-整体”的层次结构。组合使得用户对单个对象的和组合对象的使用具有一致性。

关键词：属性结构、接口一致

`Mark` 协议的对象的使用。`UIView` 对象与其子视图的关系。

### 迭代器

迭代器模式：提供一种方法顺序访问一个聚合对象的各个元素，而又不需要暴露该对象的内部表示。

关键词：顺序访问各个元素

`MarkEnumerator` 自定义枚举迭代器的实现。

## 行为扩展

### 访问者

访问者模式：表示一个作用于某对象结构中各元素的操作，它让我们可以在不改变各个元素的类的前提下，定义作用于这些元素的新操作。

关键词：作用于同一结构的各个元素的操作

`MarkRenderer` 类实现了 `MarkVisitor` 协议，成为访问者。其中实现了 `-visitMark:`、`-visitDot:`、`-visitVertex:`、`-visitStroke:`访问方法，其中对应的就是各种元素的绘制。而 `Dot`、`Vertex`、`Stroke`类自身则实现了 `Mark` 协议中的 `-acceptMarkVisitor:` 方法，调用作为参数的访问者的对应的访问方法。

把实际的实现抽离到访问者中，通过调用访问者接口与参数传递实现逻辑连接。

### 装饰

装饰模式：动态给一个对象添加一些额外的职责。（从扩展功能的角度来说，装饰模式相比成为子类更为灵活。）

不改变现有的行为与接口。

可以使用 Objective-C 的分类/范畴实现装饰模式。

### 责任链

责任链模式：使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间发生耦合。此模式将对象连成一条链，并沿着这条链传递请求，直到有一个对象处理它为止。

关键词：链传递、多个处理窗口

细化每一个操作，每一个操作只处理其本操作影响的对象，若本操作无法处理，则把处理传递给下一任。

## 算法封装

### 模板方法

模板方法模式：定义一个操作中算法的骨架，而将一些步骤延迟到子类中。模板方法使子类可以重定义算法的某些特定步骤而不改变算法的结构。

关键词：钩子方法、在父类定义，实现延迟到子类的方法

例如 UIView 的 `-drawRect:` 方法，只是个钩子方法，需要子类实现。还例如 UIViewController 中需要子类重载实现的一些方法。

### 策略

策略模式：定义一些列算法，把一个个封装起来，并且它们可以相互替换。以使得算法可独立于使用它的客户而变化。

关键词：封装算法为策略

如果代码中有很多条件语句，则意味着需要把它们重构成各种策略对象。

把算法封装成算法（这也提高了可重用性），在具有相同父类的子类对象中连接这些策略，使用相同的接口（方法名）调用策略。换句话说，把条件语句内的逻辑，封装到具体的子类中。

### 命令

命令模式：将请求封装为一个对象，从而可用不同的请求对客户进行参数化、对请求排队或记录请求日志，以及支持可撤销的操作。

使用 `NSMethodSignature` 对象把方法封装到 `NSInvocation` 对象中，向 `NSUndoManager` 注册撤销、恢复方法。以上操作在替换掉原来的直接方法调用。这样操作后，就可以使用 undoManager 属性调用 `-undo` 和 `-redo` 方法实现撤销与恢复了。

关键词：请求封装为对象

## 性能与对象访问

### 享元

享元模式：运用共享技术有效地支持大量细粒度的对象。

实现共享模式的两个关键组件：可共享的享元对象和保存他们的池，某种中央对象（工厂、管理器）维护这个池，并从它返回适当的实例。

### 代理

代理模式：为其他对象提供一种代理，以控制对这个对象的访问。

## 对象状态

### 备忘录

备忘录模式：在不破坏封装的前提下，获取一个对象的内部状态，并在该对象之外保存这个状态。这样以后就可以将该对象恢复到原先保存的状态。

关键词：在对象之外归档，以备以后恢复。